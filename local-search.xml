<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>python和tensorflow语法</title>
    <link href="/2021/06/09/python%E5%92%8Ctensorflow%E8%AF%AD%E6%B3%95/"/>
    <url>/2021/06/09/python%E5%92%8Ctensorflow%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="python语法："><a href="#python语法：" class="headerlink" title="python语法："></a>python语法：</h2><p>1、python中的self：表示当前类的对象，可以调用当前类中的属性和方法。</p><p>  给实例变量绑定属性，用def  init  __(self)方法，______init ____方法的第一个参数永远是 self ，表示创建的实例本身。在类中定义的函数第一个参数永远是self</p><p>2、python中类的实例化，创建实例化是通过 类名+() 实现的</p><p>3、私有变量是在名称前以两个下划线开头，只有内部可以访问，一定要外部访问时，调用格式为_类名__变量名</p><p>4、python中的注释：单行用#，多行用三个单引号或三个双引号括起来</p><p>5、class后跟类名，类名后跟(object)，表示该类是从哪个类继承下来的，通常，如果没有合适的继承类，就使用object 类，这是所有类最终都会 继承的类</p><p>6、from A import a1 是从A模块导入a1工具（可以是某个 函数，全局变量，类）；</p><p>   import A是导入整个A模块的全部内容（包括全部的函数，全局变量，类）。</p><h2 id="tensorflow函数"><a href="#tensorflow函数" class="headerlink" title="tensorflow函数"></a>tensorflow函数</h2><p>tf.placeholder :占位函数，声明时没有将输入的数据传入模型，在session建立之后，运行模型时才会将数据喂入占位符</p><p>tf.reshape(tensor,shape,name=None): 将tensor变换为shape形式</p><p>tf.reduce_mean：计算张量tensor沿着某一维度上的平均值</p><p>tf.summary.histogram：用于查看一个张量在训练过程中值的分布情况，其分布情况以直方图的形式在TensorBoard直方图仪表板上显示．</p><p>tf.ones_like：创建一个和输入参数维度一样，元素都为1的张量</p><p>tf.nn.sigmoid_cross_entropy_with_logits：对于给定的logits计算sigmoid的交叉熵（？），衡量的是分类任务中的概率误差</p><p>tf.summary.scalar：显示标量的信息 </p><p>tf.contrib.layers.flatten：卷积神经网络全连接层前的预处理</p><p>tf.multiply：两个相乘的数元素各自相乘 （不是矩阵乘法）</p><p>tf.gradients：求导</p><p>np.random.shuffle：重新排序返回一个随机序列</p><p>tf.variable_scope：用于定义创建变量(层)的操作的上下文管理器（？）</p><p>tf.contrib.layers.batch_norm：加速神经网络训练</p><p>tf.concat：拼接张量</p><p>tf.nn.conv2d：实现卷积操作</p>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Models】基于深度生成模型的语义图像修复</title>
    <link href="/2021/06/09/Models%E3%80%91%E5%9F%BA%E4%BA%8E%E6%B7%B1%E5%BA%A6%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B%E7%9A%84%E8%AF%AD%E4%B9%89%E5%9B%BE%E5%83%8F%E4%BF%AE%E5%A4%8D/"/>
    <url>/2021/06/09/Models%E3%80%91%E5%9F%BA%E4%BA%8E%E6%B7%B1%E5%BA%A6%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B%E7%9A%84%E8%AF%AD%E4%B9%89%E5%9B%BE%E5%83%8F%E4%BF%AE%E5%A4%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="1-摘要"><a href="#1-摘要" class="headerlink" title="1.摘要"></a>1.摘要</h1><p>  语义图像修复是一件有挑战性的工作，因为大量缺失区域的填充需要基于有用的可视数据。现有的方法仅靠单个图像提取信息，而这种图像通常会因为缺失高级内容而产生不怎么满意的效果。在这篇文章中，我们提出一个全新的语义图像修复办法，这种方法会以有用的信息为条件而产生缺失内容。在得到一个已训练好的生成器模型之后，多样化的使用我们的内容和先前损失来搜寻在隐图像中和受损图像最接近的编码。这个编码之后会通过生成模型从而推断出缺失内容。在我们的方法中，推论的结果可能不会和缺失内容的结构有关，然而目前最好的算法是根据在训练阶段孔洞的确切信息来学习基础方法的。在三个数据集上的实验成功显示了我们的方法很好的断言了大范围的缺失信息，并且实现了像素级别的照片真实化，很显然的超过了当前最好的算法。</p><h1 id="2-涉及的技术"><a href="#2-涉及的技术" class="headerlink" title="2.涉及的技术"></a>2.涉及的技术</h1><p>1、GAN</p><p>2、Autoencoders</p><p>3、Back-propagation to the input data （输入数据的反向传播）</p><h1 id="3-通过约束进行图像生成的语义修复"><a href="#3-通过约束进行图像生成的语义修复" class="headerlink" title="3.通过约束进行图像生成的语义修复"></a>3.通过约束进行图像生成的语义修复</h1><p>  论文中的G和D都是用没有缺损的数据进行训练的。</p><p>  在训练之后，G能够从p<sub>z</sub>中得到向量$z$，并且生成模仿自p<sub>data</sub>样本中的一张图像。论文假设G十分有效，因此不是来自p<sub>data</sub>（比方说受损图像）中的图像就不应该依赖于已学习过的多样性编码$z$。</p><p>  因此，我们的目标是在受manifold约束的同时修复 $\hat{z}$的编码，使其“最接近”于受损图像。如Fig.3所示，我们可视化了latent manifold，这里使用了数据可视化算法t-SNE显示在二维空间中，并且显示了寻找$\hat{z}$的每次最优步骤的中间结果。在得到$\hat{z}$之后，我们就可以通过已训练好的生成器模型G来生成缺失的区域。</p><p>  更确切地，我们将找到$\hat{z}$的过程公式化为一个找最优解的问题。让$y$表示缺损图像，M表示和缺损图像大小相同的二值掩膜，来表示缺损区域。</p><p>  在$\hat{z}$的表达式中，$L$<sub>c</sub>表示上下文损失，它用来在输入损坏图像$y$和掩膜M的情况下，对生成的图像进行约束。$L$<sub>p</sub>表示先前损失，它用来惩罚不真实的图像。</p><p>  除了提出的方法，还可以考虑通过最大化$D(y)$让$D$来更新$y$，就像在DeepDream里的反向传播或是神经风格转移。但是，受损的数据$y$既不是从一张真实图像的分布中得到的，也不是从生成图像的分布中得到的。因此，最大化$D(y)$可能会导致与latent image manifold相差甚远的结果，这样就会使生成图像的质量很差。</p><h2 id="3-1-重要性加权上下文损失"><a href="#3-1-重要性加权上下文损失" class="headerlink" title="3.1 重要性加权上下文损失"></a>3.1 重要性加权上下文损失</h2><p>  为了填补大的损失区域，我们的方法利用了剩余的有用数据，并设计出上下文损失来捕获这样的信息。一个简便的表示上下文损失的方法是，采用在生成采样$G(z)$和输入图像$y$的未损失部分之间的$l$<sub>2</sub>范数。但是，这样的损失对每个像素都是公平的，这并不是论文想要的结果。</p><p>  考虑这样一种情况：缺失的是中间块。影响整体损失的很大一部分因素来自于远离孔洞的像素，比方说脸后面的背景。所以为了找到正确的编码，应该重点关注孔洞周围区域的像素。</p><p>  为了达成修复的目标从而提出了上下文缺失的概念，并伴以假设：未受损像素的重要性和它周围受损像素的数量呈正相关。在修复过程中远离任何孔洞的像素都不会起到什么作用。用权重$W$来完成这种假设。公式中$i$是像素索引，$W$<sub>$i$</sub>代表像素位置$i$上的重要性权重，$N(i)$代表在局部窗口的像素$i$周围的一系列像素，$|N(i)|$代表$N(i)$的基数（？）。论文在所有的实验中使用的窗口大小为7.</p><p>  从经验上讲，论文发现$l$<sub>1</sub>范数比$l$<sub>2</sub>范数要好。定义上下文损失为在已修复的图像和未损失部分之间的$l$<sub>1</sub>范数差，并给出公式。</p><h2 id="3-2-先前损失"><a href="#3-2-先前损失" class="headerlink" title="3.2 先前损失"></a>3.2 先前损失</h2><p>   先前损失是基于高级图像特征显示而不是像素差异的一类惩罚。在论文所做的工作中，先前损失会使修复了的图像与训练集中提取的样本相似。论文中的先前损失和在[14]中定义的有些不同，它用了预先训练的神经网络所得到的特征。</p><p>  先前损失用来惩罚不真实的图像。回想一下，在GANs中，鉴别器D被训练来区分生成图像和真实图像。因此，论文选择先前损失与训练D时GAN的损失相同。</p><p>  公式中，λ参数用来平衡两个损失。$z$被更新来欺骗D并且使相应的生成图像更加真实。如果没有$L$<sub>p</sub>，则从$y$到$z$的映射会收敛到感知上令人难以置信的结果。论文通过举例显示这一种不稳定的状态，并在Fig.4中显示了对有$L$<sub>p</sub>和没有$L$<sub>p</sub>进行优化的结果。</p><h2 id="3-3-修复"><a href="#3-3-修复" class="headerlink" title="3.3 修复"></a>3.3 修复</h2><p>  在掌握了已定义的先前损失和上下文损失后，缺损图像可以映射到潜在表现空间中最相近的$z$，我们定义为$\hat{z}$。$z$被随机初始化，并且通过在等式(2)中反向传播的整体损失进行更新。Fig.3(b)显示了$z$在latent image manifold中接近想要的结果的一个例子。</p><p>  在生成$G$($\hat{z}$)之后，可以通过叠加来自输入的未损坏像素轻松获得修复结果。但是，我们发现尽管内容正确并且对齐良好，预测的像素可能无法完好保留与周围像素一样的强度。泊松混合用于重建最终结果。关键思想是保持$G$($\hat{z}$)的梯度以保留图像细节，同时不断变化颜色以使其和输入图像$y$中的颜色匹配。我们最终的结果$\hat{x}$可以通过公式(6)得到。</p><p>  在公式中 ∇ 是梯度算子。最小化问题包含了一个二次项，它具有唯一解。在Fig.5中显示了有无泊松混合的两个例子。</p><h2 id="3-4-实施细节"><a href="#3-4-实施细节" class="headerlink" title="3.4 实施细节"></a>3.4 实施细节</h2><p>  一般来说，论文所作的成果和特定的GAN架构正交，并且论文中的方法可以利用任何生成器模型G。作者在实验中使用了[32]中的DCGAN模型架构。生成器模型G取自[-1,1]之间的均匀分布的随机100维向量，并生成64×64×3的图像。鉴别器模型D基本上以相反的顺序构造。输入层是维度为64×64×3的图像，其后是一系列卷积层，图像的维度是一半，并且通道数是先前层的两倍，输出层是一个二分类器。</p><p>  为了训练DCGAN模型，论文使用了[32]中的训练过程还有Adam优化器。在实验中λ的值设定为0.003。论文还使用了随机水平翻转的数据增强来训练图像。在修复阶段，需要使用反向传播在隐空间中找到$\hat{z}$。论文使用Adam来进行优化，并且在每一次迭代中限制$z$在[-1,1]之间，观察到这样会产生更稳定的结果。论文在1500次迭代后终止了反向传播。论文对所有测试数据集和掩膜使用了相同的设置。</p><h1 id="4-实验"><a href="#4-实验" class="headerlink" title="4. 实验"></a>4. 实验</h1><h2 id="4-1-数据集和掩膜"><a href="#4-1-数据集和掩膜" class="headerlink" title="4.1 数据集和掩膜"></a>4.1 数据集和掩膜</h2><p>  论文在三个数据集上评估提出的方法： theCelebFaces Attributes Dataset (CelebA) [23], the Street View House Numbers (SVHN) [29] and the Stanford Cars Dataset [17]。</p><p>  在CelebA数据集中，论文从中移除了大约2000张图像来测试，图像在中央被剪切成64×64的大小，其中包含了各种视点和表情。</p><p>  测试了四种形状的掩膜：</p><p>  1.中央块</p><p>  2.约25%缺失的随机图案掩膜</p><p>  3.80%的完全随机掩膜</p><p>  4.有一半缺失的掩膜（水平或竖直随机）</p><h1 id="代码笔记"><a href="#代码笔记" class="headerlink" title="代码笔记"></a>代码笔记</h1><ol><li>np.random.randn(d0,d1,…,dn)  rand函数根据指定维度生成[0,1)之间的数据，包含0，不包含1</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>论文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>毕设-理论部分关键点（答辩）</title>
    <link href="/2021/06/09/%E6%AF%95%E8%AE%BE-%E7%90%86%E8%AE%BA%E9%83%A8%E5%88%86%E5%85%B3%E9%94%AE%E7%82%B9%EF%BC%88%E7%AD%94%E8%BE%A9%EF%BC%89/"/>
    <url>/2021/06/09/%E6%AF%95%E8%AE%BE-%E7%90%86%E8%AE%BA%E9%83%A8%E5%88%86%E5%85%B3%E9%94%AE%E7%82%B9%EF%BC%88%E7%AD%94%E8%BE%A9%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>DCGAN中生成器采用的卷积神经网络被称为“小步长卷积”，它用来实现图像的上采样。</p><p>判别器采用的是一个传统的卷积神经网络。</p><p>图像上采样：放大图像，提高图片分辨率</p><p>  待处理的图片（待修复图片）是一个概率分布中的样本，这个概率分布超复杂并且难到无法用一个通用的概率密度函数来表示。因为找不到这样的一个函数，所以修复就换成其他方法：用一个生成模型来学习如何生成新的、随机的样本</p><h2 id="答辩时可能需要注意的一些地方："><a href="#答辩时可能需要注意的一些地方：" class="headerlink" title="答辩时可能需要注意的一些地方："></a>答辩时可能需要注意的一些地方：</h2><h4 id="1-DCGAN-相比于GAN-或者是普通CNN-的改进包含以下几个方面："><a href="#1-DCGAN-相比于GAN-或者是普通CNN-的改进包含以下几个方面：" class="headerlink" title="1.DCGAN 相比于GAN 或者是普通CNN 的改进包含以下几个方面："></a>1.DCGAN 相比于GAN 或者是普通CNN 的改进包含以下几个方面：</h4><p>（1）使用卷积和去卷积代替池化层</p><p>（2）在生成器和判别器中都添加了批量归一化操作</p><p>（3）去掉了全连接层，使用全局池化层替代</p><p>（4）生成器的输出层使用Tanh 激活函数，其他层使用RELU</p><p>（5）判别器的所有层都是用LeakyReLU 激活函数</p><h4 id="2-对epoch、batch、（iteration、sample）的理解"><a href="#2-对epoch、batch、（iteration、sample）的理解" class="headerlink" title="2.对epoch、batch、（iteration、sample）的理解"></a>2.对epoch、batch、（iteration、sample）的理解</h4><p>  当一个完整的数据集通过了一次神经网络并返回了一次，这个过程叫做一个epoch。使用的epoch数量不固定，需要对应模型拟合的情况来定。（多了可能过拟合）</p><p>  在不能将数据一次性通过神经网络的时候，就需要将数据集分成几个 batch。batch就是n个样本的集合。</p><p>  迭代iteration是 batch 需要完成一个 epoch 的次数。</p><p>  sample：样本，数据集中的一个元素，一条数据。如在卷积神经网络中，一张图像是一个样本。</p><h4 id="3-为什么选DCGAN和WGAN，尤其是WGAN？两个有什么不同（代码-理论）？"><a href="#3-为什么选DCGAN和WGAN，尤其是WGAN？两个有什么不同（代码-理论）？" class="headerlink" title="3.为什么选DCGAN和WGAN，尤其是WGAN？两个有什么不同（代码+理论）？"></a>3.为什么选DCGAN和WGAN，尤其是WGAN？两个有什么不同（代码+理论）？</h4><p>  两个都是在原始GAN上的升级和改进，原始GAN使用的是全连接的神经网络，DCGAN将其改为了卷积神经网络，可以利用卷积神经网络在特征提取上的优势，从而生成质量更好的图片。</p><p>  使用WGAN首先是考虑到原始GAN上的一些缺点，比如模式崩溃和训练不稳定。首先模式崩溃，也就是Gan产生的样本单一，结果相似度高，无法保证多样性。稳定性问题主要体现在三个方面，①很难使生成器和判别器同时收敛，也就是达到势均力敌的平衡状态。②生成器发生模式崩溃 ③生成器发生梯度消失，这出现在判别器的判别效果非常准确，损失很快收敛到0从而无法提供可靠的路径使生成器的梯度继续更新，造成生成器梯度消失。</p><p>  （使用了Wassertein Distance的GAN就叫做WGAN。因此在实现WGAN时有两种思路，1.在DCGAN的基础上改JS散度为Wasserstein距离。2.写出原始GAN，改动四处，分别是D的最后一层不取sigmoid；D和G的loss不取对数；使用截断参数c；使用不基于动量的优化算法。）</p><p>  说实话，我是按照思路2的方法改的，如果是2的话，我觉得应该还要改下G和D的网络结构，因为毕竟是从DCGAN上copy过来的，要把卷积神经网络改为全连接神经网络。但是俺不会orz。过了几天后再想，可以直接用DCGAN的网络的，（这一点在一篇CSDN博上看到了），WGAN可以使用原始GAN的网络结构也可以使用DCGAN的网络结构，并且使用了CNN的WGAN生成效果质量要比DCGAN更好一些</p><p>​    </p><h4 id="4-代码讲解（这里注释要标仔细才行）"><a href="#4-代码讲解（这里注释要标仔细才行）" class="headerlink" title="4.代码讲解（这里注释要标仔细才行）"></a>4.代码讲解（这里注释要标仔细才行）</h4><ul><li>（简单提一下这个论文就行）chen c的论文“论文所作的成果和特定的GAN架构正交，并且论文中的方法可以利用任何生成器模型G”</li><li>一些训练的技巧，如批归一化，加入批量归一化可以最终生成明显更清晰的图像</li><li>WGAN使用了练5次D再练1次G的技巧，和Wasserstein GAN论文中所提相同</li><li>在训练WGAN时可以看到d loss是负的，这是因为使用了Wasserstein距离，也就是EM距离，它的d loss公式是tf.reduce_mean(d_fake) - tf.reduce_mean(d_real)，并且和g loss一起都很接近与0都是0.几</li><li>WGAN使用的优化算法是RMSProp，为了解决梯度不稳定的情况</li></ul><h4 id="5-修复图片所用到的理论能否说出个一二，修复原理是什么"><a href="#5-修复图片所用到的理论能否说出个一二，修复原理是什么" class="headerlink" title="5.修复图片所用到的理论能否说出个一二，修复原理是什么"></a>5.修复图片所用到的理论能否说出个一二，修复原理是什么</h4><p>   首先将未受损的图片输入生成器和判别器中进行训练，然后将带有掩膜（受损）图片输入进网络，在输入进生成器后能不断产生接近完好的图片。</p><p>  在生成过程中采用了两个损失分别是上下文损失和先验损失。上下文损失就是将修复之后的图片和输入图片的未破损区域进行比较，比较的主要像素区域是受损部分周围的像素，这样就会产生一种权重来表示像素的重要性，这种权重构成了损失函数。先验损失用来惩罚不真实的图像，因为在GAN中判别器D被训练来区分生成图像和真实图像。因此，论文选择先前损失与训练D时GAN的损失相同。</p><h4 id="6-对于最后交互界面的设计（pyqt5的使用），以及连接数据库的操作叙述一下逻辑"><a href="#6-对于最后交互界面的设计（pyqt5的使用），以及连接数据库的操作叙述一下逻辑" class="headerlink" title="6.对于最后交互界面的设计（pyqt5的使用），以及连接数据库的操作叙述一下逻辑"></a>6.对于最后交互界面的设计（pyqt5的使用），以及连接数据库的操作叙述一下逻辑</h4><p>  其实一开始是用PySide2模块进行设计的，主要是用这个包里面的Qt Designer拖动控件，但是将.ui文件转为.py代码后不方便修改，网上参考的资料也比较少，因此改用和它类似的pyqt5模块进行设计，（原因主要是能够方便的用代码控制运行逻辑，并且遇到了问题在网上搜索解决方案也会更多）</p><p>  因为系统的编写语言是python，下载好python3.6之后sqlite数据库就内置在里面，所以就用了这个数据库。因为对数据的操作只涉及到登录和注册，因此只有一张用户表，存了用户名和密码。</p><p>自己想的三个问题：</p><p>1.为什么会选择GAN作为修复技术：GAN相比传统方法（生成效果好）、VAE（摆脱了模糊的缺点）、RNN循环神经网络（它训练难度高）的优点；GAN是现今一个比较火热的研究方向且生成质量尚可</p><p>2.选择DCGAN，WGAN的原因：从模型本身来说，他们都是由原始GAN改进的模型，DCGAN将全连接神经网络改为了卷积神经网络，可以利用卷积神经网络在特征提取上的优势，从而生成质量更好的图片。WGAN。。。（参考上面问题3）；从修复系统来说，DCGAN是我在搜索使用GAN进行图像修复的论文中的一种比较普遍使用的方法，而WGAN解决了原始GAN上的一些缺点，比如模式崩溃和训练不稳定，能够对GAN进行更好的训练。</p><p>3.系统还有什么改进的地方：对于WGAN可以在进行些探索，比如更改网络结构、使用WGAN-GP等。其中WGAN-GP使用了梯度惩罚，能够更加有效的解决训练困难、收敛速度慢等问题。</p>]]></content>
    
    
    
    <tags>
      
      <tag>毕设</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>毕设-GAN代码笔记以及运行成果</title>
    <link href="/2021/06/09/%E6%AF%95%E8%AE%BE-GAN%E4%BB%A3%E7%A0%81%E7%AC%94%E8%AE%B0%E4%BB%A5%E5%8F%8A%E8%BF%90%E8%A1%8C%E6%88%90%E6%9E%9C/"/>
    <url>/2021/06/09/%E6%AF%95%E8%AE%BE-GAN%E4%BB%A3%E7%A0%81%E7%AC%94%E8%AE%B0%E4%BB%A5%E5%8F%8A%E8%BF%90%E8%A1%8C%E6%88%90%E6%9E%9C/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
    <tags>
      
      <tag>毕设</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>word排版小技巧</title>
    <link href="/2021/06/09/word%E6%8E%92%E7%89%88%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    <url>/2021/06/09/word%E6%8E%92%E7%89%88%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="word排版小技巧"><a href="#word排版小技巧" class="headerlink" title="word排版小技巧"></a>word排版小技巧</h1><ul><li><p>设定好正文和各种标题的样式模板后，封面出现如下情况？</p><img src="/2021/06/09/word%E6%8E%92%E7%89%88%E5%B0%8F%E6%8A%80%E5%B7%A7/1.png" alt="实例-论文封面" style="zoom:50%;"><p>方法：将每行的行距设置成“单倍行距”，插入图片出现此类问题同理</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>word</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pycharm小白遇坑</title>
    <link href="/2021/06/07/pycharm%E5%B0%8F%E7%99%BD%E9%81%87%E5%9D%91/"/>
    <url>/2021/06/07/pycharm%E5%B0%8F%E7%99%BD%E9%81%87%E5%9D%91/</url>
    
    <content type="html"><![CDATA[<h2 id="1-pycharm命令行下载数据集出现-No-module-named-requests"><a href="#1-pycharm命令行下载数据集出现-No-module-named-requests" class="headerlink" title="1.pycharm命令行下载数据集出现 No module named requests"></a>1.pycharm命令行下载数据集出现 No module named requests</h2><p><img src="/2021/06/07/pycharm%E5%B0%8F%E7%99%BD%E9%81%87%E5%9D%91/1.png" alt="1"></p><p>没有那就下呗，先按照往常直接在pycharm的setting中下载：</p><p><img src="/2021/06/07/pycharm%E5%B0%8F%E7%99%BD%E9%81%87%E5%9D%91/2.png" alt="2"></p><p>再次运行pycharm命令行，没解决。</p><p>遂打开cmd，进入python36虚拟环境，pip下载：</p><p><img src="/2021/06/07/pycharm%E5%B0%8F%E7%99%BD%E9%81%87%E5%9D%91/3.png" alt="3"></p><p>显示下载成功。现在情况是pycharm的project中有requests包，通过cmd也下载了下来，但是pycharm无法使用。</p><p>发现一个问题，在pycharm的terminal中运行download.py，它使用的包是gan36项目的venv里面的，不是anaconda虚拟幻境里的。</p><p><strong>解决：</strong></p><p>我之前每次运程序的时候都是在pycharm的terminal中直接打的命令，这是一种运行方式，还有一种是直接在菜单栏中点”run”：</p><img src="/2021/06/07/pycharm%E5%B0%8F%E7%99%BD%E9%81%87%E5%9D%91/4.png" alt="4" style="zoom: 67%;"><img src="/2021/06/07/pycharm%E5%B0%8F%E7%99%BD%E9%81%87%E5%9D%91/5.png" alt="5" style="zoom:67%;"><img src="/2021/06/07/pycharm%E5%B0%8F%E7%99%BD%E9%81%87%E5%9D%91/6.png" alt="6" style="zoom: 50%;"><p>在这两处可以修改运行的.py程序名和需要输入的参数。按照命令的要求输入后程序可以运行了！</p><p>所以并不是我的requests包安装的环境或是位置有问题，配置是正确的。</p><p>在之后又发现了requests.Session找不到的问题，是怀疑是requests下载的版本不合适，换成了2.22.0版本。然后又出现了有关HttpConnection的错误，从google登陆网站时被墙了，所以干脆自己在网上找网盘或国内提供数据集的网站下载数据集。</p><h2 id="2-下载好django包无法在命令行中使用："><a href="#2-下载好django包无法在命令行中使用：" class="headerlink" title="2.下载好django包无法在命令行中使用："></a>2.下载好django包无法在命令行中使用：</h2><img src="/2021/06/07/pycharm%E5%B0%8F%E7%99%BD%E9%81%87%E5%9D%91/7.png" alt="7" style="zoom: 67%;"><p><strong>解决：</strong></p><p>激活虚拟环境，再在想要创建web项目的路径下输入“django-admin startproject showPage”，如下：</p><img src="/2021/06/07/pycharm%E5%B0%8F%E7%99%BD%E9%81%87%E5%9D%91/8.png" alt="8" style="zoom:67%;"><p>【django命令】</p><p>启动项目：python manage.py runserver 8000</p><p>为了实现用户的登录和注册功能，在showPage项目中新建一个app，app理解为一个子模块，为实现功能的模块化，“将一些相对外部独立，但内部关系紧密的组件，组合在一个app中”。</p><h2 id="3-pycharm社区版没有直接连接数据库的拓展"><a href="#3-pycharm社区版没有直接连接数据库的拓展" class="headerlink" title="3.pycharm社区版没有直接连接数据库的拓展"></a>3.pycharm社区版没有直接连接数据库的拓展</h2><p> 需要通过第三方库或者插件进行链接，这次选择安装DataBase Navigater插件</p><p>【页面渲染】：从一个网页的Url开始,根据Url所对应的网页各项资源,输出可视化的结果的过程</p><h2 id="4-一些小问题"><a href="#4-一些小问题" class="headerlink" title="4.一些小问题"></a>4.一些小问题</h2><p>（1）一般出现这个错误是运行程序的参数设置问题，解决：在菜单栏的run执行</p><p><img src="/2021/06/07/pycharm%E5%B0%8F%E7%99%BD%E9%81%87%E5%9D%91/9.png" alt="9"></p><p>（2）我的Django是2.0版本之后，这里要加一个app名的参数，不然汇会报“django.core.exceptions.ImproperlyConfigured”错误</p><img src="/2021/06/07/pycharm%E5%B0%8F%E7%99%BD%E9%81%87%E5%9D%91/10.png" style="zoom:67%;"><p>（3）改时区</p><img src="/2021/06/07/pycharm%E5%B0%8F%E7%99%BD%E9%81%87%E5%9D%91/11.png" alt="11" style="zoom:67%;"><p>这样的话”Connection“右下角就不会出现红色感叹号显示时区问题了</p><img src="/2021/06/07/pycharm%E5%B0%8F%E7%99%BD%E9%81%87%E5%9D%91/12.png" alt="12" style="zoom:67%;">]]></content>
    
    
    
    <tags>
      
      <tag>pycharm</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
